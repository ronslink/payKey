import { Injectable, Logger, Inject, Optional } from '@nestjs/common';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import type { Cache } from 'cache-manager';

const PDFDocument = require('pdfkit');
import { PayrollRecord } from './entities/payroll-record.entity';
import archiver from 'archiver';
import { Readable } from 'stream';

const PAYSLIP_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

@Injectable()
export class PayslipService {
  private readonly logger = new Logger(PayslipService.name);

  // Fallback in-memory cache if Redis not available
  private readonly memoryCache = new Map<
    string,
    { buffer: Buffer; timestamp: number }
  >();

  constructor(
    @Optional() @Inject(CACHE_MANAGER) private cacheManager?: Cache,
  ) {}

  /**
   * Generate a single payslip PDF
   * Uses Redis caching (or fallback in-memory) to avoid regenerating identical payslips
   */
  async generatePayslip(
    record: PayrollRecord,
    employerName?: string,
    useCache = true,
  ): Promise<Buffer> {
    const cacheKey = `payslip:${record.id}:${record.updatedAt.getTime()}`;

    // Check cache (Redis or in-memory)
    if (useCache) {
      if (this.cacheManager) {
        const cached = await this.cacheManager.get<string>(cacheKey);
        if (cached) {
          this.logger.debug(`Redis cache hit for payslip ${record.id}`);
          return Buffer.from(cached, 'base64');
        }
      } else if (this.memoryCache.has(cacheKey)) {
        const cached = this.memoryCache.get(cacheKey)!;
        if (Date.now() - cached.timestamp < PAYSLIP_CACHE_TTL) {
          this.logger.debug(`Memory cache hit for payslip ${record.id}`);
          return cached.buffer;
        }
        this.memoryCache.delete(cacheKey);
      }
    }
    return new Promise<Buffer>((resolve, reject) => {
      const doc = new PDFDocument({ margin: 50 });
      const buffers: Buffer[] = [];

      doc.on('data', (buffer: Buffer) => buffers.push(buffer));
      doc.on('end', () => resolve(Buffer.concat(buffers)));
      doc.on('error', (err: any) => reject(err));

      // Header
      doc.fontSize(20).text('PAYSLIP', { align: 'center' }).moveDown();

      doc.fontSize(12).text('PAYSLIP', { align: 'center' }).moveDown();

      // Worker & Period Details
      // Worker & Period Details
      const payPeriodName = record.payPeriod?.name || record.payPeriodId;

      doc
        .fontSize(10)
        .text(`Employer: ${employerName || 'Employer'}`, { align: 'left' })
        .text(`Worker: ${record.worker.name}`, { align: 'left' })
        .text(`KRA PIN: ${record.worker.kraPin || 'N/A'}`, { align: 'left' })
        .moveDown(0.5)
        .text(`Pay Period: ${payPeriodName}`)
        .text(`Date Paid: ${new Date().toLocaleDateString()}`)
        .moveDown();

      // Earnings Section
      doc
        .fontSize(14)
        .text('Earnings', { underline: true })
        .fontSize(10)
        .moveDown(0.5);

      this.addCurrencyRow(doc, 'Gross Salary', Number(record.grossSalary));
      if (Number(record.bonuses) > 0) {
        this.addCurrencyRow(doc, 'Bonuses', Number(record.bonuses));
      }
      if (Number(record.otherEarnings) > 0) {
        this.addCurrencyRow(
          doc,
          'Other Earnings',
          Number(record.otherEarnings),
        );
      }

      const totalEarnings =
        Number(record.grossSalary) +
        Number(record.bonuses) +
        Number(record.otherEarnings);
      doc.moveDown(0.5);
      this.addCurrencyRow(doc, 'Total Earnings', totalEarnings, true);
      doc.moveDown();

      // Deductions Section
      doc
        .fontSize(14)
        .text('Deductions', { underline: true })
        .fontSize(10)
        .moveDown(0.5);

      this.addCurrencyRow(
        doc,
        'PAYE (Tax)',
        Number(record.taxBreakdown?.paye || 0),
      );
      this.addCurrencyRow(doc, 'NSSF', Number(record.taxBreakdown?.nssf || 0));
      this.addCurrencyRow(doc, 'SHIF', Number(record.taxBreakdown?.nhif || 0));
      this.addCurrencyRow(
        doc,
        'Housing Levy',
        Number(record.taxBreakdown?.housingLevy || 0),
      );

      if (Number(record.otherDeductions) > 0) {
        this.addCurrencyRow(
          doc,
          'Other Deductions',
          Number(record.otherDeductions),
        );
      }

      const totalDeductions =
        Number(record.taxBreakdown?.totalDeductions || 0) +
        Number(record.otherDeductions);
      doc.moveDown(0.5);
      this.addCurrencyRow(doc, 'Total Deductions', totalDeductions, true);
      doc.moveDown();

      // Net Pay
      doc
        .fontSize(16)
        .font('Helvetica-Bold')
        .text(`Net Pay: KES ${Number(record.netSalary).toFixed(2)}`, {
          align: 'right',
        });

      // Footer
      doc
        .moveDown(2)
        .fontSize(8)
        .font('Helvetica')
        .text('Generated by PayKey', { align: 'center', color: 'grey' });

      doc.end();
    }).then(async (buffer) => {
      // Cache the generated PDF (Redis or in-memory)
      if (useCache) {
        if (this.cacheManager) {
          await this.cacheManager.set(
            cacheKey,
            buffer.toString('base64'),
            PAYSLIP_CACHE_TTL,
          );
        } else {
          this.memoryCache.set(cacheKey, { buffer, timestamp: Date.now() });
          this.cleanupMemoryCache();
        }
      }
      return buffer;
    });
  }

  /**
   * Generate multiple payslips in parallel with optimized performance
   * @param records Array of payroll records
   * @param maxConcurrent Maximum number of concurrent PDF generations (default: 10)
   * @returns Array of buffers in the same order as input records
   */
  async generatePayslipsBatch(
    records: PayrollRecord[],
    employerName?: string,
    maxConcurrent = 10,
  ): Promise<Buffer[]> {
    const startTime = Date.now();
    this.logger.log(`Starting batch generation for ${records.length} payslips`);

    // Process in chunks to avoid memory issues
    const results: Buffer[] = [];

    for (let i = 0; i < records.length; i += maxConcurrent) {
      const chunk = records.slice(i, i + maxConcurrent);
      const chunkResults = await Promise.all(
        chunk.map((record) => this.generatePayslip(record, employerName, true)),
      );
      results.push(...chunkResults);

      this.logger.debug(
        `Processed ${Math.min(i + maxConcurrent, records.length)}/${records.length} payslips`,
      );
    }

    const duration = Date.now() - startTime;
    this.logger.log(
      `Batch generation completed: ${records.length} payslips in ${duration}ms (${(duration / records.length).toFixed(2)}ms avg)`,
    );

    return results;
  }

  /**
   * Generate a ZIP file containing multiple payslips
   * @param records Array of payroll records
   * @returns Stream containing the ZIP file
   */
  async generatePayslipsZip(
    records: PayrollRecord[],
    employerName?: string,
  ): Promise<{ stream: Readable; filename: string }> {
    this.logger.log(`Generating ZIP archive for ${records.length} payslips`);

    // Generate all PDFs in parallel (single employer name for all)
    const pdfs = await this.generatePayslipsBatch(records, employerName);

    // Create ZIP archive
    const archive = archiver('zip', {
      zlib: { level: 9 }, // Maximum compression
    });

    // Add each PDF to the archive
    records.forEach((record, index) => {
      const filename = this.sanitizeFilename(
        `payslip-${record.worker.name}-${record.payPeriodId}.pdf`,
      );
      archive.append(pdfs[index], { name: filename });
    });

    // Finalize the archive
    archive.finalize();

    const timestamp = new Date().toISOString().split('T')[0];
    const zipFilename = `payslips-${timestamp}.zip`;

    return {
      stream: archive,
      filename: zipFilename,
    };
  }

  /**
   * Clean up expired in-memory cache entries
   */
  private cleanupMemoryCache(): void {
    const now = Date.now();
    const keysToDelete: string[] = [];

    for (const [key, value] of this.memoryCache.entries()) {
      if (now - value.timestamp > PAYSLIP_CACHE_TTL) {
        keysToDelete.push(key);
      }
    }

    keysToDelete.forEach((key) => this.memoryCache.delete(key));

    if (keysToDelete.length > 0) {
      this.logger.debug(
        `Cleaned up ${keysToDelete.length} expired cache entries`,
      );
    }
  }

  /**
   * Clear all cached payslips
   */
  clearCache(): void {
    this.memoryCache.clear();
    this.logger.log('Payslip memory cache cleared');
  }

  /**
   * Sanitize filename to remove invalid characters
   */
  private sanitizeFilename(filename: string): string {
    return filename.replace(/[^a-zA-Z0-9.-]/g, '_');
  }

  private addCurrencyRow(
    doc: any,
    label: string,
    amount: number,
    isBold = false,
  ) {
    const y = doc.y;
    doc
      .font(isBold ? 'Helvetica-Bold' : 'Helvetica')
      .text(label, 50, y)
      .text(`KES ${amount.toFixed(2)}`, 300, y, { align: 'right' });
  }
}
