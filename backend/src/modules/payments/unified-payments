import {
  Controller,
  Get,
  Post,
  Put,
  Body,
  Param,
  Request,
  UseGuards,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';
import { StripeService } from './stripe.service';
import { MpesaService } from './mpesa.service';
import { Transaction, TransactionStatus, TransactionType } from './entities/transaction.entity';
import { Subscription } from '../subscriptions/entities/subscription.entity';
import { SubscriptionPayment, PaymentStatus } from '../subscriptions/entities/subscription-payment.entity';
import { TaxPaymentsService } from '../tax-payments/services/tax-payments.service';

interface PaymentDashboardData {
  overview: {
    totalTransactions: number;
    totalAmount: number;
    successfulTransactions: number;
    pendingTransactions: number;
    failedTransactions: number;
    subscriptionsActive: number;
    taxPaymentsPending: number;
  };
  recentTransactions: any[];
  paymentMethods: {
    mpesa: {
      status: string;
      balance: number;
    };
    stripe: {
      status: string;
      accountConnected: boolean;
    };
  };
  subscription: {
    currentPlan: string;
    nextBilling: Date | null;
    amount: number;
  };
  taxPayments: {
    totalDue: number;
    nextDeadline: string;
    pendingPayments: number;
  };
}

@Controller('payments/unified')
@UseGuards(JwtAuthGuard)
export class UnifiedPaymentsController {
  constructor(
    private stripeService: StripeService,
    private mpesaService: MpesaService,
    private taxPaymentsService: TaxPaymentsService,
    @InjectRepository(Transaction)
    private transactionRepository: Repository<Transaction>,
    @InjectRepository(Subscription)
    private subscriptionRepository: Repository<Subscription>,
    @InjectRepository(SubscriptionPayment)
    private subscriptionPaymentRepository: Repository<SubscriptionPayment>,
  ) {}

  @Get('dashboard')
  async getDashboard(@Request() req: any): Promise<PaymentDashboardData> {
    const userId = req.user.userId;

    // Get transaction statistics
    const totalTransactions = await this.transactionRepository.count({
      where: { userId },
    });

    const successfulTransactions = await this.transactionRepository.count({
      where: { userId, status: TransactionStatus.COMPLETED },
    });

    const pendingTransactions = await this.transactionRepository.count({
      where: { userId, status: TransactionStatus.PENDING },
    });

    const failedTransactions = await this.transactionRepository.count({
      where: { userId, status: TransactionStatus.FAILED },
    });

    // Get total amount
    const amountResult = await this.transactionRepository
      .createQueryBuilder('transaction')
      .select('SUM(transaction.amount)', 'total')
      .where('transaction.userId = :userId', { userId })
      .andWhere('transaction.status = :status', { status: TransactionStatus.COMPLETED })
      .getRawOne();

    const totalAmount = parseFloat(amountResult?.total || '0');

    // Get active subscriptions
    const activeSubscriptions = await this.subscriptionRepository.count({
      where: { userId, status: 'ACTIVE' as any },
    });

    // Get recent transactions
    const recentTransactions = await this.transactionRepository.find({
      where: { userId },
      order: { createdAt: 'DESC' },
      take: 10,
    });

    // Get current subscription
    const currentSubscription = await this.subscriptionRepository.findOne({
      where: { userId, status: 'ACTIVE' as any },
    });

    // Get tax payments data
    const currentDate = new Date();
    const monthlyTaxSummary = await this.taxPaymentsService.generateMonthlySummary(
      userId,
      currentDate.getFullYear(),
      currentDate.getMonth() + 1,
    );

    // Get payment methods status
    const stripeAccountInfo = await this.stripeService.getAccountInfo();
    const mpesaStatus = 'connected'; // In production, you'd check actual connection status

    return {
      overview: {
        totalTransactions,
        totalAmount,
        successfulTransactions,
        pendingTransactions,
        failedTransactions,
        subscriptionsActive: activeSubscriptions,
        taxPaymentsPending: monthlyTaxSummary.taxes.filter(t => t.status === PaymentStatus.PENDING).length,
      },
      recentTransactions,
      paymentMethods: {
        mpesa: {
          status: mpesaStatus,
          balance: 0, // Would be calculated from account balance
        },
        stripe: {
          status: stripeAccountInfo.connected ? 'connected' : 'not_configured',
          accountConnected: stripeAccountInfo.connected,
        },
      },
      subscription: {
        currentPlan: currentSubscription?.tier || 'FREE',
        nextBilling: currentSubscription?.nextBillingDate,
        amount: currentSubscription?.amount || 0,
      },
      taxPayments: {
        totalDue: monthlyTaxSummary.totalDue,
        nextDeadline: monthlyTaxSummary.paymentInstructions.deadline,
        pendingPayments: monthlyTaxSummary.taxes.filter(t => t.status === PaymentStatus.PENDING).length,
      },
    };
  }

  @Post('subscribe')
  async createSubscription(
    @Request() req: any,
    @Body() body: { planId: string; paymentMethod: 'stripe' },
  ): Promise<{ checkoutUrl: string }> {
    try {
      const userId = req.user.userId;
      const userEmail = req.user.email;
      const userName = req.user.name || req.user.email;

      const checkoutSession = await this.stripeService.createCheckoutSession(
        userId,
        body.planId.toUpperCase(),
        userEmail,
        userName,
      );

      return {
        checkoutUrl: checkoutSession.url,
      };
    } catch (error) {
      throw new HttpException(
        error.message || 'Failed to create subscription',
        HttpStatus.BAD_REQUEST,
      );
    }
  }

  @Put('subscriptions/:id/cancel')
  async cancelSubscription(
    @Request() req: any,
    @Param('id') subscriptionId: string,
  ): Promise<{ message: string }> {
    try {
      const userId = req.user.userId;

      // Verify subscription belongs to user
      const subscription = await this.subscriptionRepository.findOne({
        where: { id: subscriptionId, userId },
      });

      if (!subscription) {
        throw new HttpException('Subscription not found', HttpStatus.NOT_FOUND);
      }

      await this.stripeService.cancelSubscription(userId);

      return {
        message: 'Subscription cancelled successfully',
      };
    } catch (error) {
      throw new HttpException(
        error.message || 'Failed to cancel subscription',
        HttpStatus.BAD_REQUEST,
      );
    }
  }

  @Post('mpesa/topup')
  async initiateMpesaTopup(
    @Request() req: any,
    @Body() body: { phoneNumber: string; amount: number },
  ): Promise<any> {
    try {
      const userId = req.user.userId;

      const result = await this.mpesaService.initiateStkPush(
        userId,
        body.phoneNumber,
        body.amount,
      );

      return {
        success: true,
        checkoutRequestId: result.CheckoutRequestID,
        message: 'STK push initiated successfully',
      };
    } catch (error) {
      throw new HttpException(
        error.message || 'Failed to initiate M-Pesa topup',
        HttpStatus.BAD_REQUEST,
      );
    }
  }

  @Post('tax-payments/record')
  async recordTaxPayment(
    @Request() req: any,
    @Body() body: {
      taxType: string;
      amount: number;
      paymentDate?: string;
      reference: string;
    },
  ): Promise<any> {
    try {
      const userId = req.user.userId;

      const taxPayment = await this.taxPaymentsService.recordPayment(userId, {
        taxType: body.taxType as any,
        amount: body.amount,
        paymentDate: body.paymentDate ? new Date(body.paymentDate) : undefined,
        paymentMethod: 'bank_transfer',
        reference: body.reference,
      });

      return {
        success: true,
        paymentId: taxPayment.id,
        message: 'Tax payment recorded successfully',
      };
    } catch (error) {
      throw new HttpException(
        error.message || 'Failed to record tax payment',
        HttpStatus.BAD_REQUEST,
      );
    }
  }

  @Get('tax-payments/summary')
  async getTaxPaymentSummary(@Request() req: any): Promise<any> {
    try {
      const userId = req.user.userId;
      const currentDate = new Date();

      const summary = await this.taxPaymentsService.generateMonthlySummary(
        userId,
        currentDate.getFullYear(),
        currentDate.getMonth() + 1,
      );

      return summary;
    } catch (error) {
      throw new HttpException(
        error.message || 'Failed to get tax payment summary',
        HttpStatus.BAD_REQUEST,
      );
    }
  }

  @Get('methods')
  async getPaymentMethods(@Request() req: any): Promise<any> {
    const userId = req.user.userId;

    const stripeAccount = await this.stripeService.getAccountInfo();
    const activeSubscription = await this.subscriptionRepository.findOne({
      where: { userId, status: 'ACTIVE' as any },
    });

    return {
      stripe: {
        configured: !!stripeAccount.connected,
        accountId: stripeAccount.id,
        chargesEnabled: stripeAccount.charges_enabled,
        payoutsEnabled: stripeAccount.payouts_enabled,
      },
      mpesa: {
        configured: true, // Would check actual M-Pesa configuration
        shortcode: '174379', // From environment
      },
      subscription: {
        active: !!activeSubscription,
        tier: activeSubscription?.tier,
        status: activeSubscription?.status,
      },
    };
  }
}